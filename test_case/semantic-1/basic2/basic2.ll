; Autogenerated textual LLVM IR
source_filename = "RCompiler"

define i64 @main() {
entry:
  %a = alloca i64
  store i64 0, ptr %a
  %b = alloca i64
  store i64 0, ptr %b
  %operator = alloca i64
  store i64 0, ptr %operator
  %result = alloca i64
  store i64 0, ptr %result
  %doubled = alloca i64
  store i64 0, ptr %doubled
  %acc = alloca i64
  store i64 0, ptr %acc
  %i = alloca i64
  store i64 0, ptr %i
  %final_score = alloca i64
  store i64 0, ptr %final_score
  store i64 10, ptr %a
  store i64 20, ptr %b
  %t1 = load i64, ptr %a
  %t2 = call i64 @pick_operator(i64 %t1)
  store i64 %t2, ptr %operator
  %t3 = load i64, ptr %operator
  %t4 = icmp eq i64 %t3, 0
  %t5 = zext i1 %t4 to i64
  %t6 = icmp ne i64 %t5, 0
  br i1 %t6, label %then1, label %else2
then1:
  %t7 = load i64, ptr %a
  %t8 = load i64, ptr %b
  %t9 = call i64 @compute(i64 %t7, i64 %t8, i64 0)
  br label %ifend3
else2:
  %t10 = load i64, ptr %a
  %t11 = load i64, ptr %b
  %t12 = call i64 @compute(i64 %t10, i64 %t11, i64 0)
  br label %ifend3
ifend3:
  %t13 = phi i64 [ %t9, %then1 ], [ %t12, %else2 ]
  store i64 %t13, ptr %result
  %t14 = load i64, ptr %result
  %t15 = mul i64 %t14, 2
  store i64 %t15, ptr %doubled
  store i64 0, ptr %acc
  store i64 0, ptr %i
  br label %while4
while4:
  %t16 = load i64, ptr %i
  %t17 = load i64, ptr %doubled
  %t18 = icmp slt i64 %t16, %t17
  %t19 = zext i1 %t18 to i64
  %t20 = icmp ne i64 %t19, 0
  br i1 %t20, label %whilebody5, label %whileexit6
whilebody5:
  %t21 = load i64, ptr %i
  store i64 %t21, ptr %acc
  store i64 1, ptr %i
  br label %while4
whileexit6:
  %t22 = load i64, ptr %acc
  %t23 = sdiv i64 %t22, 3
  store i64 %t23, ptr %final_score
  ret i64 0
}

define i64 @pick_operator(i64 %p0) {
entry:
  %value = alloca i64
  store i64 %p0, ptr %value
  %t1 = load i64, ptr %value
  %t2 = icmp sgt i64 %t1, 5
  %t3 = zext i1 %t2 to i64
  %t4 = icmp ne i64 %t3, 0
  br i1 %t4, label %then1, label %else2
then1:
  ret i64 0
else2:
  ret i64 0
ifend3:
  ret i64 0
}

define i64 @compute(i64 %p0, i64 %p1, i64 %p2) {
entry:
  %x = alloca i64
  store i64 %p0, ptr %x
  %y = alloca i64
  store i64 %p1, ptr %y
  %op = alloca i64
  store i64 %p2, ptr %op
  %accumulator = alloca i64
  store i64 0, ptr %accumulator
  %i = alloca i64
  store i64 0, ptr %i
  store i64 0, ptr %accumulator
  store i64 0, ptr %i
  br label %while1
while1:
  %t1 = load i64, ptr %i
  %t2 = load i64, ptr %y
  %t3 = icmp slt i64 %t1, %t2
  %t4 = zext i1 %t3 to i64
  %t5 = icmp ne i64 %t4, 0
  br i1 %t5, label %whilebody2, label %whileexit3
whilebody2:
  %t6 = load i64, ptr %accumulator
  %t7 = load i64, ptr %x
  %t8 = add i64 %t6, %t7
  %t9 = load i64, ptr %i
  %t10 = add i64 %t8, %t9
  store i64 %t10, ptr %accumulator
  store i64 1, ptr %i
  br label %while1
whileexit3:
  %t11 = load i64, ptr %op
  %t12 = icmp eq i64 %t11, 0
  %t13 = zext i1 %t12 to i64
  %t14 = icmp ne i64 %t13, 0
  br i1 %t14, label %then4, label %else5
then4:
  %t15 = load i64, ptr %accumulator
  %t16 = load i64, ptr %y
  %t17 = add i64 %t15, %t16
  ret i64 %t17
else5:
  ret i64 0
ifend6:
  ret i64 0
}

define i64 @Dummy__new() {
entry:
  %t1 = alloca [2 x i64]
  %t2 = getelementptr [2 x i64], ptr %t1, i64 0, i64 0
  store i64 0, ptr %t2
  %t3 = zext i1 0 to i64
  %t4 = getelementptr [2 x i64], ptr %t1, i64 0, i64 1
  store i64 %t3, ptr %t4
  %t5 = ptrtoint ptr %t1 to i64
  ret i64 %t5
}

@.fmt_int = private constant [5 x i8] c"%ld\0A\00"
@.fmt_in = private constant [4 x i8] c"%ld\00"
declare i32 @printf(ptr, ...)
declare i32 @scanf(ptr, ...)
declare void @exit(i32)

define i64 @printlnInt(i64 %p0) {
entry:
  %fmt = getelementptr [5 x i8], ptr @.fmt_int, i64 0, i64 0
  %r = call i32 (ptr, ...) @printf(ptr %fmt, i64 %p0)
  ret i64 %p0
}

define i64 @getInt() {
entry:
  %tmp = alloca i64
  %fmt = getelementptr [4 x i8], ptr @.fmt_in, i64 0, i64 0
  %r = call i32 (ptr, ...) @scanf(ptr %fmt, ptr %tmp)
  %v = load i64, ptr %tmp
  ret i64 %v
}

define void @exit_rt(i64 %code) {
entry:
  %c = trunc i64 %code to i32
  call void @exit(i32 %c)
  ret void
}

