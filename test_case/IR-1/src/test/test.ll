; Autogenerated textual LLVM IR
source_filename = "RCompiler"

define i64 @main() {
entry:
  %t2 = alloca [17 x i64]
  %t3 = alloca i64
  store i64 0, ptr %t3
  %t1 = alloca [17 x i64]
  call void @Stack__new(ptr %t1)
  call void @llvm.memcpy.p0.p0.i64(ptr %t2, ptr %t1, i64 136, i1 false)
  %t4 = trunc i64 0 to i32
  %t5 = sext i32 %t4 to i64
  store i64 %t5, ptr %t3
  br label %while1
while1:
  %t6 = load i64, ptr %t3
  %t7 = trunc i64 %t6 to i32
  %t8 = sext i32 %t7 to i64
  %t9 = trunc i64 10 to i32
  %t10 = sext i32 %t9 to i64
  %t11 = icmp slt i64 %t8, %t10
  %t12 = zext i1 %t11 to i64
  %t13 = icmp ne i64 %t12, 0
  br i1 %t13, label %whilebody2, label %whileexit3
whilebody2:
  %t14 = call i64 @getInt()
  %t15 = call i64 @Stack__push(ptr %t2, i64 %t14)
  %t16 = load i64, ptr %t3
  %t17 = trunc i64 %t16 to i32
  %t18 = sext i32 %t17 to i64
  %t19 = trunc i64 1 to i32
  %t20 = sext i32 %t19 to i64
  %t21 = add i64 %t18, %t20
  %t22 = trunc i64 %t21 to i32
  %t23 = sext i32 %t22 to i64
  store i64 %t23, ptr %t3
  br label %while1
whileexit3:
  br label %while4
while4:
  %t24 = call i64 @Stack__empty(ptr %t2)
  %t25 = icmp ne i64 %t24, 0
  %t26 = xor i1 %t25, 1
  %t27 = zext i1 %t26 to i64
  %t28 = icmp ne i64 %t27, 0
  br i1 %t28, label %whilebody5, label %whileexit6
whilebody5:
  %t29 = call i64 @Stack__pop(ptr %t2)
  %t30 = call i64 @printlnInt(i64 %t29)
  br label %while4
whileexit6:
  ret i64 0
}

define void @Stack__new(ptr %ret) {
entry:
  %t1 = alloca [17 x i64]
  %t2 = alloca [16 x i64]
  call void @llvm.memset.p0.i64(ptr %t2, i8 0, i64 128, i1 false)
  %t3 = getelementptr [17 x i64], ptr %t1, i64 0, i64 0
  call void @llvm.memcpy.p0.p0.i64(ptr %t3, ptr %t2, i64 128, i1 false)
  %t4 = getelementptr [17 x i64], ptr %t1, i64 0, i64 16
  store i64 0, ptr %t4
  call void @llvm.memcpy.p0.p0.i64(ptr %ret, ptr %t1, i64 136, i1 false)
  ret void
}

define i64 @Stack__push(ptr %p0, i64 %p1) {
entry:
  %t1 = alloca i64
  store i64 %p1, ptr %t1
  %t2 = load i64, ptr %t1
  %t3 = getelementptr [17 x i64], ptr %p0, i64 0, i64 0
  %t4 = getelementptr [17 x i64], ptr %p0, i64 0, i64 16
  %t5 = load i64, ptr %t4
  %t6 = mul i64 %t5, 1
  %t7 = getelementptr i64, ptr %t3, i64 %t6
  %t8 = trunc i64 %t2 to i32
  %t9 = sext i32 %t8 to i64
  store i64 %t9, ptr %t7
  %t10 = getelementptr [17 x i64], ptr %p0, i64 0, i64 16
  %t11 = load i64, ptr %t10
  %t12 = add i64 %t11, 1
  store i64 %t12, ptr %t10
  ret i64 0
}

define i64 @Stack__pop(ptr %p0) {
entry:
  %t1 = getelementptr [17 x i64], ptr %p0, i64 0, i64 16
  %t2 = load i64, ptr %t1
  %t3 = trunc i64 %t2 to i32
  %t4 = sext i32 %t3 to i64
  %t5 = trunc i64 0 to i32
  %t6 = sext i32 %t5 to i64
  %t7 = icmp eq i64 %t4, %t6
  %t8 = zext i1 %t7 to i64
  %t9 = icmp ne i64 %t8, 0
  br i1 %t9, label %then1, label %else2
then1:
  ret i64 0
else2:
  br label %ifend3
ifend3:
  %t10 = getelementptr [17 x i64], ptr %p0, i64 0, i64 16
  %t11 = load i64, ptr %t10
  %t12 = sub i64 %t11, 1
  store i64 %t12, ptr %t10
  %t13 = getelementptr [17 x i64], ptr %p0, i64 0, i64 0
  %t14 = getelementptr [17 x i64], ptr %p0, i64 0, i64 16
  %t15 = load i64, ptr %t14
  %t16 = mul i64 %t15, 1
  %t17 = getelementptr i64, ptr %t13, i64 %t16
  %t18 = load i64, ptr %t17
  ret i64 %t18
}

define i64 @Stack__empty(ptr %p0) {
entry:
  %t1 = getelementptr [17 x i64], ptr %p0, i64 0, i64 16
  %t2 = load i64, ptr %t1
  %t3 = trunc i64 %t2 to i32
  %t4 = sext i32 %t3 to i64
  %t5 = trunc i64 0 to i32
  %t6 = sext i32 %t5 to i64
  %t7 = icmp eq i64 %t4, %t6
  %t8 = zext i1 %t7 to i64
  ret i64 %t8
}

declare i32 @printf(ptr, ...)
declare i32 @scanf(ptr, ...)
declare void @exit(i32)
declare i64 @printInt(i64)
declare i64 @printlnInt(i64)
declare i64 @printlnStr(ptr)
declare i64 @getInt()
declare void @exit_rt(i64)

declare void @llvm.memset.p0.i64(ptr, i8, i64, i1)

declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)

